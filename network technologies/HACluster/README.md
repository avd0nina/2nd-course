# CLUSTER

Кластер — это группа связанных между собой компьютеров (нод), работающих совместно, как единая система, чтобы обеспечить высокую производительность или балансировку нагрузки.  Они связаны сетью и обмениваются данными.

## Зачем нужны кластеры?
Кластеры позволяют:
1. Увеличить скорость вычислений
Если задача слишком большая для одного компьютера, кластер позволяет разделить ее на части и выполнить параллельно на нескольких узлах.
2. Балансировать нагрузку между узлами
Когда много пользователей обращаются к сервису (например, веб-сайту), кластер распределяет запросы между узлами, чтобы ни один из них не был перегружен.
3. Обеспечить отказоустойчивость
Если один компьютер выходит из строя, другие узлы в кластере берут на себя его задачи, чтобы сервис продолжал работать без перебоев.
4. Абстрагироваться от физического "железа"
Кластер позволяет не зависеть от конкретного оборудования. Пользователь работает с кластером как с единым ресурсом, не задумываясь, на каком именно компьютере выполняется задача.
5. Использовать как основу для облачных сервисов

## Как реализуются кластеры?
1. Grid Computing 
- Узлы (компьютеры) могут быть разнородными (разные ОС, железо)
- Объединены через стандартные сети (Ethernet)
- Сами по себе ненадежны, но их много, и это компенсирует нестабильность
2. Суперкомпьютеры
- Узлы однородные
- Связаны через высокоскоростную сеть (InfiniBand, Fibre Channel)
- Сильно оптимизированы под ресурсоемкие задачи

## Виды кластеров
1. High-Availability (HA) Clusters — кластеры высокой доступности
Основная задача — отказоустойчивость. Если одна нода умирает — другая автоматически берёт на себя её задачи.
Как это работает:
- Узлы следят друг за другом через специальные программы, такие как Pacemaker и Corosync.
- Если один узел "падает", другой автоматически запускает нужные сервисы. Например, если сервер с базой данных MySQL выходит из строя, другой сервер активирует копию базы данных.
- Ресурсы — это всё, что нужно для работы сервиса: IP-адрес, файловая система, база данных и т.д. Ресурсы можно "переносить" между узлами. Для этого используются скрипты, которые умеют запускать (start), останавливать (stop) и проверять состояние (monitor) ресурса.
2. Load Balancing (LB) Clusters — кластеры с балансировкой нагрузки
Делят входящие запросы на несколько нод, чтобы ускорить обработку и избежать перегрузки.
Как это работает:
- Специальный сервер (например, HA Proxy) принимает все запросы и перенаправляет их на менее загруженные узлы.
- Это повышает производительность и предотвращает перегрузку.
Пример архитектуры:
Используется HAProxy — программа, распределяющая трафик
Несколько back-end серверов обрабатывают запросы

## Из каких слоев состоит кластер?

### 1. Pacemaker — "Менеджер команды"
Pacemaker — это программа, которая управляет ресурсами в кластере. Она следит за тем, чтобы всё работало правильно, и решает, что делать, если что-то ломается.
Что делает Pacemaker?
- Управляет ресурсами: Ресурсы — это всё, что нужно для работы сервиса (например, веб-сервер Apache, база данных MySQL, IP-адрес). Pacemaker решает, на каком узле (компьютере) должен работать каждый ресурс.
- Следит за здоровьем узлов: Если один узел "падает" (например, выключается), Pacemaker переносит ресурсы на другой узел, чтобы сервис не остановился.
- Запускает и останавливает сервисы: Pacemaker использует скрипты, которые умеют запускать (start), останавливать (stop) и проверять состояние (monitor) ресурсов (см. лекцию, страница 12).
Пример из жизни: Представь, что Pacemaker — это менеджер в пиццерии. Он решает, кто из поваров готовит какую пиццу, следит, чтобы никто не простаивал, и, если один повар уходит, передает его заказы другому. В лекции (страница 22) Pacemaker называется Cluster Resource Manager (CRM), то есть "управляющий ресурсами кластера".

### 2. Corosync — "Рация для общения"
Corosync — это программа, которая отвечает за связь между узлами в кластере. Она позволяет узлам "разговаривать" друг с другом, чтобы они знали, кто жив, кто умер, и что происходит.
Что делает Corosync?
- Обеспечивает коммуникацию: Узлы обмениваются сообщениями (например, "я жив", "я готов взять задачу").
- Синхронизирует состояние: Corosync помогает узлам договориться, кто управляет ресурсами, чтобы не было путаницы.
- Обнаруживает сбои: Если один узел перестает отвечать, Corosync сообщает об этом Pacemaker, чтобы тот принял меры.
Пример из жизни: Corosync — это как рации, которые повара в пиццерии используют, чтобы координировать свои действия. Если один повар говорит: "Я занят, бери заказ!", другой сразу берет на себя работу. Если рация молчит, значит, повар "выпал", и менеджер (Pacemaker) переназначает его задачи.
Пример из лекции (страница 23): Corosync работает вместе с Pacemaker в HA-кластере. Он передает сообщения между узлами, чтобы Pacemaker знал, какие узлы активны и где запускать ресурсы.

### 3. HAProxy — "Диспетчер заказов"
HAProxy — это программа, которая распределяет входящие запросы между узлами в кластере. Она используется для балансировки нагрузки (Load Balancing), чтобы ни один узел не был перегружен.
Что делает HAProxy?
- Распределяет запросы: Если к твоему сайту обращаются 1000 пользователей, HAProxy делит их запросы между серверами, чтобы каждый обрабатывал, например, 500 запросов.
- Проверяет доступность узлов: Если один сервер ломается, HAProxy перестает отправлять ему запросы и перенаправляет всё на рабочие серверы.
- Работает как входная точка: Пользователи обращаются к одному IP-адресу (виртуальному), а HAProxy "раздает" запросы по узлам.
Пример из жизни: HAProxy — это как администратор в пиццерии, который принимает заказы от клиентов и распределяет их между поварами. Если один повар занят, администратор отправляет заказ другому. Если повар уволился, администратор вообще не дает ему заказов.
Пример из лекции (страница 11): В кластере есть два сервера (Back-end1 и Back-end2). HAProxy принимает запросы от пользователей (например, к сайту) и распределяет их между этими серверами. Если Back-end1 ломается, HAProxy отправляет все запросы на Back-end2.

### Как они взаимодействуют и создают кластер?
Теперь давай соберем всё вместе. Pacemaker, Corosync и HAProxy работают как части одного механизма, чтобы создать HA-кластер (кластер высокой доступности) или LB-кластер (кластер балансировки нагрузки). Вот как это происходит:
1) Corosync — основа коммуникации:
Corosync запускается на каждом узле кластера (например, на двух серверах).
Узлы постоянно "пингуют" друг друга через Corosync, чтобы проверить, кто жив.
Если один узел перестает отвечать, Corosync сообщает об этом Pacemaker.
2) Pacemaker — управление ресурсами:
Pacemaker следит за ресурсами (например, веб-сервер Apache, база данных MySQL, виртуальный IP-адрес).
Если Corosync сообщает, что один узел "упал", Pacemaker переносит ресурсы на другой узел. Например, если сервер с MySQL ломается, Pac MARKET Pacemaker запускает MySQL на запасном сервере.
Pacemaker также управляет HAProxy как ресурсом, чтобы он всегда был доступен.
3) HAProxy — распределение нагрузки:
HAProxy работает как "входная дверь" для пользователей. Все запросы к сайту или сервису сначала идут к HAProxy.
HAProxy распределяет запросы между узлами, чтобы они не перегружались.
Если Pacemaker сообщает, что один узел недоступен, HAProxy перестает отправлять запросы на этот узел.

## Методы балансировки нагрузки

### 1. Weighted Round Robin (Взвешенный циклический выбор)
Weighted Round Robin (WRR) — это алгоритм, который распределяет запросы между серверами по очереди, учитывая их "вес" (производительность). Более мощные серверы получают больше запросов.
Как работает?
Каждому серверу присваивается вес (число, отражающее его мощность). Например:
Сервер A (мощный) — вес 100.
Сервер B (средний) — вес 50.
Сервер C (слабый) — вес 25.
HAProxy формирует очередь и отправляет запросы по очереди, но сервер с большим весом получает больше запросов. Например, сервер A получит в два раза больше запросов, чем сервер B, и в четыре раза больше, чем сервер C.
Если сервер перегружен (например, достиг максимума соединений), HAProxy пропускает его и отправляет запрос следующему серверу, а позже возвращает его в очередь.
Это динамический алгоритм: веса можно менять на лету, если серверы становятся более или менее производительными.

### 2. Weighted Least Connections (Взвешенный выбор наименьшего числа соединений)
Weighted Least Connections (WLC) — это алгоритм, который отправляет запросы на сервер с наименьшим количеством активных соединений, учитывая его вес (производительность). Он лучше подходит для длительных соединений.
Как работает?
Каждому серверу присваивается вес, как в WRR (например, 100, 50, 25).
HAProxy выбирает сервер с наименьшим количеством активных соединений (включая ожидающие в очереди).
Внутри группы серверов с одинаковым весом запросы распределяются циклически, чтобы использовать все серверы.
Алгоритм учитывает очередь ожидания (queue.length) и максимальную очередь (maxqueue), чтобы минимизировать задержки.
Это динамический алгоритм: веса и лимиты соединений можно менять на лету.

### 3. Консистентное хеширование 
Консистентное хэширование — это алгоритм, который отправляет запросы на сервер, основываясь на хеше (числовой идентификатор) запроса и серверов. Он минимизирует изменения в распределении запросов при добавлении или удалении серверов, что важно для работы с кэшами.
Как работает?
Каждому серверу присваивается хеш (число, основанное на его имени или ID).
Для каждого запроса вычисляется хеш (например, от URL).
Запрос отправляется на сервер, чей хеш ближе всего к хешу запроса.
Если серверов становится больше или меньше, только небольшая часть запросов перенаправляется на другие серверы, что сохраняет данные в кэшах.
Пример из жизни: В пиццерии клиенты заказывают пиццу по номеру телефона. Администратор (HAProxy) смотрит, какой повар ближе к "числу" телефона клиента (по какому-то правилу). Если одного повара уволили, большинство клиентов всё равно попадают к тем же поварам, что сохраняет их заказы в работе.
Проблема: Если одно видео (или URL) очень популярно, все запросы к нему пойдут на один сервер, перегружая его.

### 4. Консистентное хеширование с ограничениями (Bounded-Load Consistent Hashing)
Консистентное хеширование с ограничениями — это улучшенная версия консистентного хеширования, которая решает проблему неравномерной нагрузки, ограничивая максимальную загрузку серверов.
Как работает?
Вводится балансирующий фактор c (обычно от 1.25 до 2), который определяет максимальный дисбаланс. Например, при c = 1.25 ни один сервер не должен быть загружен более чем на 125% от средней нагрузки.
Для каждого запроса:
Вычисляется средняя нагрузка (avg = общее число запросов / число серверов).
Целевая нагрузка на сервер: t = avg * c.
Максимальная нагрузка на сервер: [cm/n], где n — число серверов.
HAProxy вычисляет хеш URL и находит ближайший сервер по хешу. Если этот сервер не перегружен (его нагрузка ниже t), запрос отправляется на него. Если перегружен, HAProxy проверяет следующий сервер по хешу, пока не найдет подходящий.





















